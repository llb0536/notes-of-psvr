<p>Get the source code here: <a href="http://ofpsvr.org/file/tu.zip">http://ofpsvr.org/file/tu.zip</a></p>
<p>The function of the above code is to do image scaling on BMP's, using four different methods. I wrote this using Win32 API mainly because that I have to demonstrate the code in class, the computer of which only got Windows installed.</p>
<p>To compile the source code, you need <a href="http://www.codeblocks.org">CodeBlocks</a> with MinGW. Note that there is a Debian package named "mingw32-binutils" that can help you build the code even in linux.</p>
<p>Almost all the code live in main.cpp, pretty messed up admittedly. The main window is based on a dialog written in resource.rc. The program starts at WinMain() and called DialogBox() to create that main dialog. The code to respond to user actions is inside DialogProc(), where a huge switch/case resides. The skeleton of the code is:</p>
<code>
BOOL CALLBACK DialogProc0(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)<br />
BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)<br />
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)<br />
</code>
<p>So what is DialogProc0()? Well, the result of image processing is displayed in another dialog and DialogProc0 plays the handler of that sub-dialog.</p>
<p>I've implemented four image scaling methods. The first thread are all based on interpolation. After all, when zooming an image, say from 5x5 to 50x50, the target image needs more information than what the original image can provide. This is just like mathematically, you only got several known points of an unknown function and want a whole entire function.</p>
<p>The first method, Nearest-neighbor interpolation, is the method of brute-force. It simply treats the unknown pixels the same as its nearest known pixel. Therefore making the resulting interpolated function a non-continuous one. The second one, Bilinear interpolation, uses this formula
\[f(x,y) = f(0,0) \, (1-x)(1-y) + f(1,0) \, x(1-y) + f(0,1) \, (1-x)y + f(1,1) xy.\]
and makes the resulting interpolated function a continuous one. The third one, Bicubic interpolation, further treats the derivatives as essential and makes the resulting interpolated function even has the same derivatives of the original points. Of course here the derivatives are only finite differences. The third method calculates via a matrix, which I found on <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation">wikipedia</a>.
\[\left[\begin{matrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ -3 & 3 & 0 & 0 & -2 & -1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 2 & -2 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -3 & 3 & 0 & 0 & -2 & -1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & -2 & 0 & 0 & 1 & 1 & 0 & 0 \\ -3 & 0 & 3 & 0 & 0 & 0 & 0 & 0 & -2 & 0 & -1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & -3 & 0 & 3 & 0 & 0 & 0 & 0 & 0 & -2 & 0 & -1 & 0 \\ 9 & -9 & -9 & 9 & 6 & 3 & -6 & -3 & 6 & -6 & 3 & -3 & 4 & 2 & 2 & 1 \\ -6 & 6 & 6 & -6 & -3 & -3 & 3 & 3 & -4 & 4 & -2 & 2 & -2 & -2 & -1 & -1 \\ 2 & 0 & -2 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 2 & 0 & -2 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\ -6 & 6 & 6 & -6 & -4 & -2 & 4 & 2 & -3 & 3 & -3 & 3 & -2 & -1 & -2 & -1 \\ 4 & -4 & -4 & 4 & 2 & 2 & -2 & -2 & 2 & -2 & 2 & -2 & 1 & 1 & 1 & 1 \end{matrix}\right]\]
And that is stored in
</p>
<code>int bicubic_inverse_matrix[16][16];</code>
<p>When implemented, a simple matrix operation is performed, as seen in lines 402-418. The fourth method, called hq3x is mainly designed for scalar-intense images. Basically it tries to recapture the scalar information inside the image.</p>
<p>The following images can help to do the test of all those methods:<a href="http://ofpsvr.org/file/tuku2.zip">http://ofpsvr.org/file/tuku2.zip</a>. You'll find the result to be pretty interesting. I also implemented other simple image processing functions in the code, such as Transpose,Flip,Invert . They are really simple, believe me:)</p>
<p>One more technical note is that I've used the Win32 functions GetPixel() and SetPixel(), which are really slow function. You have to avoid those two functions in production applications. They are examples of drawbacks in Win32 API design.</p>